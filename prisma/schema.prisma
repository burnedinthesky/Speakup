generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgres"
    url      = env("DATABASE_URL")
}

enum UserRole {
    USER
    CREATOR
    SENIORCREATOR
    ADMIN
}

// https://next-auth.js.org/adapters/models

model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum Gender {
    m
    f
    o
}

model User {
    id            String    @id @unique @default(uuid())
    name          String    @unique
    email         String    @unique
    emailVerified DateTime?
    password      String?   @db.Char(64)

    profileImg String?
    birthday   DateTime?
    gender     Gender?
    role       UserRole  @default(USER)
    onBoarded  Boolean   @default(false)

    accounts Account[]
    sessions Session[]

    Articles  Articles[]
    Arguments Argument[] @relation("postedArguments")
    Comments  Comments[] @relation("postedComments")

    likedArguments     Argument[] @relation("likedArguments")
    dislikedArguments  Argument[] @relation("supportedArguments")
    supportedArguments Argument[] @relation("dislikedArguments")

    likedComments     Comments[] @relation("likedComments")
    dislikedComments  Comments[] @relation("supportedComments")
    supportedComments Comments[] @relation("dislikedComments")

    PrivateUser       PrivateUser?
    ArticleViews      ArticleViews[]
    Collections       Collections[]
    CollectionSet     CollectionSet[]
    CredEmailVerToken CredEmailVerToken?
    CredEmailLimiter  CredEmailLimiter?
    ArgumentReports   ArgumentReports[]
    CommentReports    CommentReports[]
    ArticleReports    ArticleReports[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model CredEmailLimiter {
    id              Int      @id @default(autoincrement())
    user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId          String   @unique
    lastEmailSent   DateTime @default(now())
    dayStartTime    DateTime @default(now())
    emailsSentInDay Int      @default(0)
}

model CredEmailVerToken {
    id          String   @id @default(cuid())
    valToken    String
    failedCount Int      @default(0)
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String   @unique
    expiers     DateTime
}

enum PrivateUserRole {
    USER
    SYSTEMADMIN
}

model PrivateUser {
    id           String @id @unique @default(uuid())
    UserInstance User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId       String @unique

    Role      PrivateUserRole @default(USER)
    AuthToken String?         @unique @db.VarChar(64)
}

model CollectionSet {
    id          Int           @id @unique @default(autoincrement())
    user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId      String
    name        String
    collections Collections[]
    createdTime DateTime      @default(now())
}

model Collections {
    id             Int             @id @unique @default(autoincrement())
    user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId         String
    article        Articles        @relation(fields: [articleId], references: [id])
    articleId      String
    collectionSets CollectionSet[]
    createdTime    DateTime        @default(now())

    @@unique([articleId, userId])
}

model Articles {
    id             String           @id @default(cuid())
    title          String           @unique
    tags           String[]
    createdTime    DateTime         @default(now())
    author         User             @relation(fields: [authorId], references: [id])
    authorId       String
    viewCount      Int              @default(0)
    content        Json
    references     Json
    arguments      Argument[]
    Collections    Collections[]
    ArticleReports ArticleReports[]
}

model ArticleViews {
    id     BigInt  @id @default(autoincrement())
    ip     String?
    user   User?   @relation(fields: [userId], references: [id])
    userId String?

    @@unique([ip, userId])
}

model ArticleReports {
    id          Int      @id @default(autoincrement())
    reasons     String[]
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    article     Articles @relation(fields: [articlesId], references: [id], onDelete: Cascade)
    createdTime DateTime @default(now())
    userId      String
    articlesId  String

    @@unique([userId, articlesId])
}

model Argument {
    id             Int      @id @default(autoincrement())
    content        String   @db.Text
    author         User     @relation("postedArguments", fields: [authorId], references: [id], onDelete: Cascade)
    authorId       String
    createdTime    DateTime @default(now())
    stance         String   @db.Text
    likedUsers     User[]   @relation("likedArguments")
    dislikedUsers  User[]   @relation("supportedArguments")
    supportedUsers User[]   @relation("dislikedArguments")

    pagnationSequence Int @unique @default(autoincrement())

    article   Articles @relation(fields: [articleId], references: [id], onDelete: Cascade)
    articleId String

    comments        Comments[]
    argumentThreads ArgumentThread[]
    ArgumentReports ArgumentReports[]
}

model ArgumentThread {
    id         Int        @id @default(autoincrement())
    name       String
    argument   Argument   @relation(fields: [argumentId], references: [id], onDelete: Cascade)
    argumentId Int
    comments   Comments[]

    @@unique([argumentId, name])
}

model ArgumentReports {
    id          Int      @id @default(autoincrement())
    reasons     String[]
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    argument    Argument @relation(fields: [argumentId], references: [id], onDelete: Cascade)
    createdTime DateTime @default(now())
    userId      String
    argumentId  Int

    @@unique([userId, argumentId])
}

model Comments {
    id             Int      @id @default(autoincrement())
    content        String   @db.Text
    author         User     @relation("postedComments", fields: [authorId], references: [id], onDelete: Cascade)
    authorId       String
    createdTime    DateTime @default(now())
    stance         String   @db.Text
    likedUsers     User[]   @relation("likedComments")
    dislikedUsers  User[]   @relation("supportedComments")
    supportedUsers User[]   @relation("dislikedComments")

    inArgument       Argument         @relation(fields: [inArgumentId], references: [id], onDelete: Cascade)
    inArgumentId     Int
    inThread         ArgumentThread?  @relation(fields: [argumentThreadId], references: [id])
    argumentThreadId Int?
    CommentReports   CommentReports[]
}

model CommentReports {
    id          Int      @id @default(autoincrement())
    reasons     String[]
    user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    comment     Comments @relation(fields: [commentsId], references: [id], onDelete: Cascade)
    createdTime DateTime @default(now())
    userId      String
    commentsId  Int

    @@unique([userId, commentsId])
}
